<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Pop Mania - Easy Mode with Math Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.2);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .game-header {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0 0 20px 20px;
            padding: 15px 40px;
            display: flex;
            gap: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .score-display, .level-display, .moves-display {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .score-display:hover, .level-display:hover, .moves-display:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.3);
        }

        canvas {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            cursor: crosshair;
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
            display: block;
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .game-over-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            display: none;
            z-index: 1000;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .game-over-modal h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .final-score {
            font-size: 24px;
            margin-bottom: 30px;
            color: #ffd700;
        }

        .restart-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .easy-mode-badge {
            position: fixed;
            top: 100px;
            right: 20px;
            background: linear-gradient(135deg, #00ff00, #32cd32);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 100;
            animation: badge-bounce 2s infinite;
        }

        @keyframes badge-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .math-quiz-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            color: white;
            display: none;
            z-index: 1000;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            animation: bounceIn 0.6s ease;
            max-width: 600px;
            width: 90%;
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .math-quiz-modal h2 {
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .math-question {
            font-size: 36px;
            font-weight: bold;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 15px;
            display: inline-block;
            min-width: 200px;
        }

        .visual-question {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .object-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .objects-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            max-width: 200px;
        }

        .math-object {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }

        .apple {
            color: #ff4757;
            font-size: 24px;
        }

        .star {
            color: #ffd700;
            font-size: 24px;
        }

        .heart {
            color: #ff6b81;
            font-size: 24px;
        }

        .circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3498db;
        }

        .square {
            width: 24px;
            height: 24px;
            background: #2ecc71;
        }

        .triangle {
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 24px solid #e74c3c;
        }

        .minus-sign {
            font-size: 36px;
            color: #FFD700;
            font-weight: bold;
        }

        .equals-sign {
            font-size: 36px;
            color: #FFD700;
            font-weight: bold;
        }

        .question-mark {
            font-size: 36px;
            color: #FFD700;
            font-weight: bold;
        }

        .answer-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 30px 0;
        }

        .answer-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 15px 20px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            position: relative;
        }

        .answer-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .answer-btn:active {
            transform: translateY(0);
        }

        .answer-btn.selected {
            background: rgba(244, 67, 54, 0.7);
            border-color: #f44336;
            animation: shake 0.5s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        .answer-btn.hinted {
            background: rgba(255, 193, 7, 0.3);
            border-color: #FFC107;
        }

        .answer-btn.correct {
            background: rgba(76, 175, 80, 0.7);
            border-color: #4CAF50;
            animation: correctPulse 0.6s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .quiz-feedback {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .quiz-feedback.correct {
            background: #4CAF50;
            color: white;
        }

        .quiz-feedback.incorrect {
            background: #f44336;
            color: white;
        }

        .quiz-feedback.show {
            opacity: 1;
            top: -60px;
        }

        .math-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .quiz-instruction {
            font-size: 16px;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .stars {
            font-size: 30px;
            margin: 10px 0;
        }

        .hint-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            display: none;
        }

        .hint-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .hint-visual {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            font-size: 24px;
            font-weight: bold;
        }

        .number-block {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 15px;
            border-radius: 10px;
            min-width: 40px;
            text-align: center;
        }

        .hint-result {
            background: rgba(255, 255, 255, 0.2);
            border: 2px dashed #FFD700;
            padding: 10px 15px;
            border-radius: 10px;
            min-width: 40px;
            text-align: center;
            position: relative;
        }

        .counting-dots {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            gap: 5px;
        }

        .dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #FFD700;
            margin: 0 2px;
        }

        .dot-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .dot-label {
            font-size: 16px;
            margin-left: 5px;
        }

        .block-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-header">
        <div class="score-display">Score: <span id="score">0</span></div>
        <div class="level-display">Level: <span id="level">1</span></div>
        <div class="moves-display">Moves: <span id="moves">0</span></div>
    </div>

    <div class="easy-mode-badge">üåü EASY MODE</div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls-hint">üéØ Move mouse to aim ‚Ä¢ Click to shoot ‚Ä¢ Answer math questions to continue!</div>

    <div class="block-overlay" id="blockOverlay"></div>

    <div class="math-quiz-modal" id="mathQuizModal">
        <div class="math-icon">üßÆ</div>
        <h2>Math Time!</h2>
        <div class="quiz-instruction">Answer correctly to continue playing!</div>
        
        <div class="visual-question" id="visualQuestion">
            <!-- Visual question will be generated by JavaScript -->
        </div>
        
        <div class="answer-options" id="answerOptions">
            <!-- Options will be generated by JavaScript -->
        </div>
        
        <div class="hint-section" id="hintSection">
            <div class="hint-text">Here's a hint to help you:</div>
            <div class="hint-visual" id="hintVisual">
                <!-- Hint will be generated by JavaScript -->
            </div>
            <div class="counting-dots" id="countingDots">
                <!-- Counting dots will be generated by JavaScript -->
            </div>
        </div>
        
        <div class="stars">‚≠ê‚≠ê‚≠ê</div>
        <div class="quiz-feedback" id="quizFeedback"></div>
    </div>

    <div class="game-over-modal" id="gameOverModal">
        <h2>üéÆ Great Job! üéÆ</h2>
        <div class="final-score">Final Score: <span id="finalScore">0</span></div>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 600;
        canvas.height = 700;

        // Game variables
        let score = 0;
        let level = 1;
        let moves = 0;
        let gameOver = false;
        let animationId;
        let waitingForAnswer = false;
        let canShoot = true;

        // Enhanced distinctive bubble colors with names
        const bubbleColors = [
            { hex: '#FF0000', name: 'Red' },      // Pure Red
            { hex: '#0000FF', name: 'Blue' },     // Pure Blue
            { hex: '#00FF00', name: 'Green' },    // Pure Green
            { hex: '#FFFF00', name: 'Yellow' },   // Pure Yellow
            { hex: '#FF00FF', name: 'Magenta' },  // Pure Magenta
            { hex: '#00FFFF', name: 'Cyan' }      // Pure Cyan
        ];

        // Game objects
        let bubbles = [];
        let shooterBubble = null;
        let nextBubble = null;
        let particles = [];
        let hints = [];
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Math quiz variables
        let currentQuestion = {};
        let correctAnswer = 0;
        let selectedAnswer = null;
        let wrongAttempts = 0;

        // Visual object types for math questions
        const objectTypes = [
            { type: 'apple', icon: 'üçé', class: 'apple' },
            { type: 'star', icon: '‚≠ê', class: 'star' },
            { type: 'heart', icon: '‚ù§Ô∏è', class: 'heart' },
            { type: 'circle', icon: '', class: 'circle' },
            { type: 'square', icon: '', class: 'square' },
            { type: 'triangle', icon: '', class: 'triangle' }
        ];

        // Bubble class
        class Bubble {
            constructor(x, y, color, radius = 30) { // Bigger bubbles
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = radius;
                this.vx = 0;
                this.vy = 0;
                this.marked = false;
                this.falling = false;
                this.opacity = 1;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                // Draw hint outline if this bubble has a hint
                const hasHint = hints.some(hint => 
                    Math.abs(hint.x - this.x) < 5 && Math.abs(hint.y - this.y) < 5
                );
                
                if (hasHint) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Main bubble with enhanced contrast
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius/3, this.y - this.radius/3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, this.lightenColor(this.color, 50));
                gradient.addColorStop(0.4, this.color);
                gradient.addColorStop(0.8, this.darkenColor(this.color, 30));
                gradient.addColorStop(1, this.darkenColor(this.color, 50));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Enhanced border for better definition
                ctx.strokeStyle = this.darkenColor(this.color, 60);
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Stronger highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Secondary highlight for depth
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x - this.radius/4, this.y - this.radius/4, this.radius/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            update() {
                if (this.falling) {
                    this.vy += 0.3; // Slower falling
                    this.x += this.vx;
                    this.y += this.vy;
                    this.opacity -= 0.02;
                    
                    if (this.y > canvas.height + 50) {
                        return false;
                    }
                }
                return true;
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255))
                    .toString(16).slice(1);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R > 0 ? R : 0) * 0x10000 +
                    (G > 0 ? G : 0) * 0x100 +
                    (B > 0 ? B : 0))
                    .toString(16).slice(1);
            }
        }

        // Particle class for effects
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.radius = Math.random() * 3 + 2;
                this.life = 1;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life -= 0.02;
                return this.life > 0;
            }
        }

        // Generate math question with visual objects
        function generateMathQuestion() {
            // Generate subtraction question
            const maxNum = 10;
            const num1 = Math.floor(Math.random() * maxNum) + 1; // 1-10
            const num2 = Math.floor(Math.random() * num1) + 1; // 1-num1 to ensure positive result
            correctAnswer = num1 - num2;
            
            // Select a random object type for this question
            const objectType = objectTypes[Math.floor(Math.random() * objectTypes.length)];
            
            // Generate 4 options (1 correct, 3 incorrect)
            const options = [correctAnswer];
            
            // Generate 3 incorrect answers
            while (options.length < 4) {
                const wrongAnswer = correctAnswer + Math.floor(Math.random() * 10) - 5;
                if (wrongAnswer >= 0 && wrongAnswer <= 10 && !options.includes(wrongAnswer)) {
                    options.push(wrongAnswer);
                }
            }
            
            // Shuffle options
            options.sort(() => Math.random() - 0.5);
            
            currentQuestion = {
                num1: num1,
                num2: num2,
                objectType: objectType,
                options: options,
                correct: correctAnswer
            };
            
            return currentQuestion;
        }

        // Show math quiz with visual objects
        function showMathQuiz() {
            waitingForAnswer = true;
            canShoot = false;
            wrongAttempts = 0;
            selectedAnswer = null;
            
            const question = generateMathQuestion();
            
            // Create visual question
            const visualQuestion = document.getElementById('visualQuestion');
            visualQuestion.innerHTML = '';
            
            // First group of objects
            const group1 = document.createElement('div');
            group1.className = 'object-group';
            
            const container1 = document.createElement('div');
            container1.className = 'objects-container';
            
            for (let i = 0; i < question.num1; i++) {
                const obj = document.createElement('div');
                obj.className = `math-object ${question.objectType.class}`;
                
                if (question.objectType.icon) {
                    obj.textContent = question.objectType.icon;
                }
                
                container1.appendChild(obj);
            }
            
            const label1 = document.createElement('div');
            label1.textContent = `${question.num1} ${question.objectType.type}s`;
            label1.style.fontSize = '18px';
            label1.style.fontWeight = 'bold';
            
            group1.appendChild(container1);
            group1.appendChild(label1);
            
            // Minus sign
            const minus = document.createElement('div');
            minus.className = 'minus-sign';
            minus.textContent = '-';
            
            // Second group of objects
            const group2 = document.createElement('div');
            group2.className = 'object-group';
            
            const container2 = document.createElement('div');
            container2.className = 'objects-container';
            
            for (let i = 0; i < question.num2; i++) {
                const obj = document.createElement('div');
                obj.className = `math-object ${question.objectType.class}`;
                
                if (question.objectType.icon) {
                    obj.textContent = question.objectType.icon;
                }
                
                container2.appendChild(obj);
            }
            
            const label2 = document.createElement('div');
            label2.textContent = `${question.num2} ${question.objectType.type}s`;
            label2.style.fontSize = '18px';
            label2.style.fontWeight = 'bold';
            
            group2.appendChild(container2);
            group2.appendChild(label2);
            
            // Equals sign
            const equals = document.createElement('div');
            equals.className = 'equals-sign';
            equals.textContent = '=';
            
            // Question mark
            const questionMark = document.createElement('div');
            questionMark.className = 'question-mark';
            questionMark.textContent = '?';
            
            // Assemble the visual question
            visualQuestion.appendChild(group1);
            visualQuestion.appendChild(minus);
            visualQuestion.appendChild(group2);
            visualQuestion.appendChild(equals);
            visualQuestion.appendChild(questionMark);
            
            // Create answer options
            const optionsContainer = document.getElementById('answerOptions');
            optionsContainer.innerHTML = '';
            
            question.options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'answer-btn';
                button.textContent = option;
                button.onclick = () => checkAnswer(option);
                optionsContainer.appendChild(button);
            });
            
            // Hide hint section initially
            document.getElementById('hintSection').style.display = 'none';
            
            document.getElementById('blockOverlay').style.display = 'block';
            document.getElementById('mathQuizModal').style.display = 'block';
        }

        // Check answer
        function checkAnswer(answer) {
            selectedAnswer = answer;
            const feedback = document.getElementById('quizFeedback');
            const buttons = document.querySelectorAll('.answer-btn');
            
            // Disable all buttons
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.cursor = 'not-allowed';
            });
            
            // Mark selected answer
            buttons.forEach(btn => {
                if (parseInt(btn.textContent) === answer) {
                    btn.classList.add('selected');
                }
            });
            
            if (answer === correctAnswer) {
                feedback.textContent = '‚úÖ Correct! Great job!';
                feedback.className = 'quiz-feedback correct show';
                
                // Mark correct answer
                buttons.forEach(btn => {
                    if (parseInt(btn.textContent) === correctAnswer) {
                        btn.classList.add('correct');
                    }
                });
                
                setTimeout(() => {
                    document.getElementById('mathQuizModal').style.display = 'none';
                    document.getElementById('blockOverlay').style.display = 'none';
                    feedback.className = 'quiz-feedback';
                    waitingForAnswer = false;
                    canShoot = true;
                }, 2000);
            } else {
                wrongAttempts++;
                feedback.textContent = '‚ùå Not quite right! Let me help you...';
                feedback.className = 'quiz-feedback incorrect show';
                
                // Show hint after a short delay
                setTimeout(() => {
                    showHint();
                }, 1500);
            }
        }

        // Show hint with visual aids
        function showHint() {
            const hintSection = document.getElementById('hintSection');
            const hintVisual = document.getElementById('hintVisual');
            const countingDots = document.getElementById('countingDots');
            
            // Create visual hint without showing the answer
            hintVisual.innerHTML = `
                <div class="number-block">${currentQuestion.num1}</div>
                <div class="minus-sign">-</div>
                <div class="number-block">${currentQuestion.num2}</div>
                <div class="equals-sign">=</div>
                <div class="hint-result">
                    <div class="question-mark">?</div>
                </div>
            `;
            
            // Create counting dots with objects
            let dotsHTML = '<div class="dot-group">';
            for (let i = 0; i < currentQuestion.num1; i++) {
                if (currentQuestion.objectType.icon) {
                    dotsHTML += `<span class="math-object ${currentQuestion.objectType.class}">${currentQuestion.objectType.icon}</span>`;
                } else {
                    dotsHTML += '<div class="dot"></div>';
                }
            }
            dotsHTML += '<div class="dot-label">(' + currentQuestion.num1 + ')</div></div>';
            
            dotsHTML += '<div class="minus-sign">-</div>';
            
            dotsHTML += '<div class="dot-group">';
            for (let i = 0; i < currentQuestion.num2; i++) {
                if (currentQuestion.objectType.icon) {
                    dotsHTML += `<span class="math-object ${currentQuestion.objectType.class}">${currentQuestion.objectType.icon}</span>`;
                } else {
                    dotsHTML += '<div class="dot"></div>';
                }
            }
            dotsHTML += '<div class="dot-label">(' + currentQuestion.num2 + ')</div></div>';
            
            countingDots.innerHTML = dotsHTML;
            
            hintSection.style.display = 'block';
            
            // Update feedback
            const feedback = document.getElementById('quizFeedback');
            feedback.textContent = `üí° Count the ${currentQuestion.objectType.type}s! Try counting on your fingers too!`;
            
            // Highlight the correct answer button with a subtle hint
            const buttons = document.querySelectorAll('.answer-btn');
            buttons.forEach(btn => {
                if (parseInt(btn.textContent) === correctAnswer) {
                    btn.classList.add('hinted');
                }
            });
            
            // Re-enable all buttons for another try
            setTimeout(() => {
                buttons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                });
            }, 1000);
        }

        // Initialize game
        function init() {
            bubbles = [];
            particles = [];
            hints = [];
            score = 0;
            level = 1;
            moves = 0;
            gameOver = false;
            waitingForAnswer = false;
            canShoot = true;
            
            // Create initial bubble grid (fewer rows)
            createBubbleGrid();
            
            // Create shooter bubble
            createShooterBubble();
            
            // Update UI
            updateUI();
        }

        // Create bubble grid (easier configuration)
        function createBubbleGrid() {
            const rows = 5 + Math.floor(level / 3); // Fewer rows
            const cols = 9; // Fewer columns
            const bubbleRadius = 30; // Bigger bubbles
            const offsetX = bubbleRadius + 20;
            const offsetY = bubbleRadius;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (Math.random() > 0.3) { // More gaps
                        const x = offsetX + col * (bubbleRadius * 2.2);
                        const y = offsetY + row * (bubbleRadius * 2);
                        const colorObj = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
                        bubbles.push(new Bubble(x, y, colorObj.hex));
                    }
                }
            }
            
            updateHints();
        }

        // Update hints for possible matches
        function updateHints() {
            hints = [];
            
            for (let bubble of bubbles) {
                if (bubble.falling) continue;
                
                // Check for 2 or more adjacent bubbles of same color
                let sameColorCount = 0;
                for (let other of bubbles) {
                    if (other !== bubble && !other.falling && other.color === bubble.color) {
                        const dx = bubble.x - other.x;
                        const dy = bubble.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < bubble.radius * 2.5) {
                            sameColorCount++;
                        }
                    }
                }
                
                if (sameColorCount >= 1) { // Only need 1 more for a match
                    hints.push({ x: bubble.x, y: bubble.y });
                }
            }
        }

        // Create shooter bubble
        function createShooterBubble() {
            // Sometimes give a color that has matches
            let colorObj;
            if (hints.length > 0 && Math.random() > 0.3) {
                const hintBubble = bubbles.find(b => 
                    hints.some(h => Math.abs(h.x - b.x) < 5 && Math.abs(h.y - b.y) < 5)
                );
                if (hintBubble) {
                    colorObj = bubbleColors.find(c => c.hex === hintBubble.color);
                }
            }
            
            if (!colorObj) {
                colorObj = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
            }
            
            shooterBubble = new Bubble(canvas.width / 2, canvas.height - 50, colorObj.hex);
            
            // Create next bubble preview
            const nextColorObj = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
            nextBubble = new Bubble(canvas.width - 50, canvas.height - 50, nextColorObj.hex, 25);
        }

        // Draw aiming line
        function drawAimLine() {
            if (!shooterBubble) return;
            
            const dx = mouseX - shooterBubble.x;
            const dy = mouseY - shooterBubble.y;
            const angle = Math.atan2(dy, dx);
            const distance = 350; // Longer aim line
            
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 3;
            ctx.setLineDash([15, 10]);
            ctx.beginPath();
            ctx.moveTo(shooterBubble.x, shooterBubble.y);
            ctx.lineTo(
                shooterBubble.x + Math.cos(angle) * distance,
                shooterBubble.y + Math.sin(angle) * distance
            );
            ctx.stroke();
            ctx.restore();
        }

        // Shoot bubble
        function shootBubble() {
            if (!shooterBubble || gameOver || !canShoot) return;
            
            const dx = mouseX - shooterBubble.x;
            const dy = mouseY - shooterBubble.y;
            const angle = Math.atan2(dy, dx);
            const speed = 10; // Slower speed
            
            shooterBubble.vx = Math.cos(angle) * speed;
            shooterBubble.vy = Math.sin(angle) * speed;
            
            moves++;
            updateUI();
        }

        // Check collisions
        function checkCollisions() {
            if (!shooterBubble || (shooterBubble.vx === 0 && shooterBubble.vy === 0)) return;
            
            // Wall collisions
            if (shooterBubble.x - shooterBubble.radius <= 0 || 
                shooterBubble.x + shooterBubble.radius >= canvas.width) {
                shooterBubble.vx = -shooterBubble.vx;
            }
            
            // Top collision
            if (shooterBubble.y - shooterBubble.radius <= 0) {
                attachBubble();
                return;
            }
            
            // Bubble collisions (more forgiving)
            for (let bubble of bubbles) {
                if (!bubble.falling) {
                    const dx = shooterBubble.x - bubble.x;
                    const dy = shooterBubble.y - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < shooterBubble.radius + bubble.radius + 5) { // Extra tolerance
                        attachBubble();
                        return;
                    }
                }
            }
        }

        // Attach bubble to grid
        function attachBubble() {
            shooterBubble.vx = 0;
            shooterBubble.vy = 0;
            bubbles.push(shooterBubble);
            
            // Check for matches
            checkMatches();
            
            // Create new shooter bubble
            shooterBubble = nextBubble;
            shooterBubble.x = canvas.width / 2;
            shooterBubble.y = canvas.height - 50;
            shooterBubble.radius = 30;
            
            // Create next bubble
            const nextColorObj = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
            nextBubble = new Bubble(canvas.width - 50, canvas.height - 50, nextColorObj.hex, 25);
            
            // Update hints
            updateHints();
            
            // Check game over
            checkGameOver();
        }

        // Check for matching bubbles (easier - only 2 needed)
        function checkMatches() {
            const matches = findMatches(shooterBubble);
            
            if (matches.length >= 2) { // Only need 2 bubbles!
                // Remove matched bubbles
                for (let bubble of matches) {
                    createParticles(bubble.x, bubble.y, bubble.color);
                    bubble.falling = true;
                    bubble.vx = (Math.random() - 0.5) * 5;
                    bubble.vy = Math.random() * -5;
                }
                
                // Update score (more points)
                score += matches.length * 15 * level;
                
                // Check for level up (easier)
                if (score > level * 300) {
                    level++;
                    createBubbleGrid();
                }
                
                updateUI();
                
                // Show math quiz after scoring
                setTimeout(() => {
                    showMathQuiz();
                }, 1000);
            }
        }

        // Find matching bubbles
        function findMatches(startBubble) {
            const matches = [startBubble];
            const visited = new Set();
            const queue = [startBubble];
            
            while (queue.length > 0) {
                const current = queue.shift();
                const key = `${Math.round(current.x)},${Math.round(current.y)}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                for (let bubble of bubbles) {
                    if (bubble !== current && !bubble.falling && bubble.color === current.color) {
                        const dx = current.x - bubble.x;
                        const dy = current.y - bubble.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < current.radius * 2.5) { // More forgiving matching
                            const bubbleKey = `${Math.round(bubble.x)},${Math.round(bubble.y)}`;
                            if (!visited.has(bubbleKey)) {
                                matches.push(bubble);
                                queue.push(bubble);
                            }
                        }
                    }
                }
            }
            
            return matches;
        }

        // Create particle effects
        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) { // More particles
                particles.push(new Particle(x, y, color));
            }
        }

        // Check game over (more forgiving)
        function checkGameOver() {
            for (let bubble of bubbles) {
                if (!bubble.falling && bubble.y + bubble.radius >= canvas.height - 50) {
                    endGame();
                    return;
                }
            }
        }

        // End game
        function endGame() {
            gameOver = true;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverModal').style.display = 'block';
        }

        // Restart game
        function restartGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            init();
            gameLoop();
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('moves').textContent = moves;
        }

        // Game loop
        function gameLoop() {
            if (gameOver) {
                cancelAnimationFrame(animationId);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background gradient
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#1e3c72');
            bgGradient.addColorStop(1, '#2a5298');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw bubbles
            bubbles = bubbles.filter(bubble => {
                const alive = bubble.update();
                if (alive) bubble.draw();
                return alive;
            });
            
            // Update and draw particles
            particles = particles.filter(particle => {
                const alive = particle.update();
                if (alive) particle.draw();
                return alive;
            });
            
            // Draw aiming line
            drawAimLine();
            
            // Update and draw shooter bubble
            if (shooterBubble) {
                shooterBubble.x += shooterBubble.vx;
                shooterBubble.y += shooterBubble.vy;
                shooterBubble.draw();
                checkCollisions();
            }
            
            // Draw next bubble preview
            if (nextBubble) {
                ctx.save();
                ctx.globalAlpha = 0.5;
                nextBubble.draw();
                ctx.restore();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('NEXT', canvas.width - 70, canvas.height - 80);
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }

        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            shootBubble();
        });

        // Initialize and start game
        init();
        gameLoop();
    </script>
</body>
</html>
